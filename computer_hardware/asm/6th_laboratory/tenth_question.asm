; Лабораторная работа №6 вариант 10
; Задание: Разработать подпрограмму, которая преобразует заданное шестнадцатеричное число в десятичную систему. 
; Разработать программу, которая вводит с клавиатуры строку шестнадцатеричных цифр и выводит на экран 
; её эквивалент в десятичной системе. Если строка не является числом, то сообщает об этом.

data segment										; директива начала сегмента данных
	text1 db 0dh, 0ah, 'Input(hex):', 0dh, 0ah, '$'			; Подсказка ввода текста
	text2 db 0dh, 0ah, 'Result(dec):', 0dh, 0ah, '$'		; строка "Результат:"
	text3 db 0dh, 0ah, 'Error', 0dh, 0ah, '$'				; сообщение об ошибке
	in_str db 250,?,250 dup (?) 							; Строка ввода
	out_str db 250,?,250 dup (?)							; Строка вывода
data ends											; директива конца сегмента данных

code segment				; директива начала сегмента кодов
	assume ds:data, cs:code		; установка соответствий сегментов и их адресов 
								; cs - указывает на код программы, ds - на данные							

	start:  				; метка входа
		mov ax, data
        mov ds, ax				; Загрузить сегментный адрес данных
	nachalo:
        lea dx, text1			; Заносим подсказку для ввода
		mov ah, 09h				; Записываем номер команды для вывода
		int 21h					; Отображаем текст
	; Ввод строки
		lea dx, in_str			; Заносим начало строки
		mov ah, 0ah				; Записываем номер команды для вывода
		int 21h					; Считываем строку
	error_:	
		mov al, in_str+1
		cmp al, 0 				; строка пустая?
		ja obr 					; нет продолжать
	error_1:
		lea dx, text3			; сообщение об ошибке
		mov ah, 09h
		int 21h 
		jmp quit 				; закончить работу
    ; Обработка
	obr:
		xor ax, ax 				; обнуление AX
        lea bx, in_str+2		; адрес начала введённой строки 
        xor cx, cx				; в СX будет лежать счётчик всей строки
        mov cl, in_str+1     	; Количество введённых символов 
        lea si, out_str+2  		; si = адрес начала вывода
	beg:   					; метка начала
		mov al, [bx]			; заносим символ из строки ввода
		cmp al, ' '				; Является ли символ пробелом?
		jz ne_probel			; Если является, то переходим на метку
		call h_to_d				; вызываем ф-ию перевода из 16 в 10 СС
	ne_probel:
		inc bx					; переходим к следующему символу в строке ввода
        loop beg				; Повторяем, пока не кончится строка
        mov byte ptr[si], '$'	; записать признак конца строки
		
	; Вывод строки
		lea dx, text2			; Заносим строку "Результат:"
		mov ah, 09h				; Записываем номер команды для вывода
		int 21h					; Отображаем текст
			
		lea dx, out_str+2			; Заносим строку вывода
		mov ah, 09h 			; функция вывода на экран
		int 21h					; Отображаем текст
		jmp nachalo				; Запускаем программу по новой
	quit:   				; метка выхода
		mov ax, 4C00h 			; Код завершения 0
		int 21h 				; Выход в DOS
        
	; Подпрограмма
h_to_d proc 
		cmp al, '0' 			; если символ меньше чем 0 - ошибка
		jb error_1
		cmp al, 'F' 			; если символ больше чем F - ошибка
		ja error_1
		cmp al, '9' 			; если символ меньше чем 9 - идём к метке
		jbe konec
		cmp al, 'A'				; если символ меньше А - ошибка
		jb error_1
		push ax					; Если ни один переход не сработал, то это буква, запоминаем значение в al
		mov byte ptr[si], '1'	; ставим единичку в строке вывода
		pop ax					; Вспоминаем значение
		inc si					; переходим к следующему символу в строке вывода
		sub al,11h				; Сделать из буквы цифру
	konec:
		mov [si], al			; заносим результат в строку вывода
		inc si					; после её выполнения в строке вывода ставим пробел
		mov byte ptr[si],' '
		inc si					; переходим к следующему символу в строке вывода
		ret						; возвращаемся в основную программу
h_to_d endp		
		
code ends					; директива конца сегмента кода
end start					; начать выполнение кода

