; Программа запрашивает ввод 2-х строк из консоли: "основной строки" и "подстроки"
; Далее программа проверяет, содержится ли подстрока в основной строке.

	.186
	assume	cs:code, ds:data, ss:stk

; Сегмент команд программы
code	segment	para public use16 "code"
main	proc
	; Настроить сегментный регистр DS на сегмент данных
	mov	ax, data	; Установить регистр сегмента данных DS,
	mov	ds, ax		; указывающим на сегмент data

	; ********** Основная часть программы **********
	; Ввести основную строку
	mov	si, offset Msg1
	call	PrnStr		; Распечатать приглашение ввода
	mov	si, offset MainSt
	mov	cx, StMaxLen
	call	InpStr		; Выполнить ввод
	; Ввести подстроку
	mov	si, offset Msg2
	call	PrnStr		; Распечатать приглашение ввода
	mov	si, offset SubSt
	mov	cx, StMaxLen
	call	InpStr		; Выполнить ввод
	; Выполнить поиск подстроки в строке
	mov	di, offset MainSt
	mov	si, offset SubSt
	call	StrPos
	; Вывод результатов
	cmp	dl, 1
	jne	@21
	; Подстрока найдена - в AX индекс вхождения
	mov	si, offset StPosStr
	mov	dh, 10          ; Вывести индекс AX в строку PosSt
	call	IntToStr	; в десятичной системе
	mov	si, offset Msg3
	call	PrnStr		; Распечатать результат - подстрока найдена
	jmp	@22
@21:	; Подстрока не найдена
	mov	si, offset Msg4
	call	PrnStr		; Распечатать результат - подстрока не найдена
@22:	mov	si, offset CRSt
	call	PrnStr          ; Перевод строки

	; ********** Завершение работы программы **********
@31:	mov	ax, 4C00h       ; Выход из
	int	21h             ; программы
main	endp

; Процедура считывает строку с клавиатуры. После нажатия Enter-ввод
; прекращается. BackSpace - стирает символ слева от курсора.
;
; Вход:  DS:SI - адрес начала памяти, куда нужно считывать строку
;        CX - максимальная длина строки (без учета терминального нулевого символа)
;             значение не может быть больше 254.
; Выход: Нуль-терминальная (оканчивающаяся нулем) строка по адресу DS:SI
;
InpStr	proc
	; Сохранить регистры
	push	ax
	push	cx
	push	dx
	push	bx
	push	si
	push	di
	; Выполнить ввод строки во вспомогательный буфер
	; с помощью функции DOS 0AH
	push	si
	mov	si, offset InpStrBuf
	inc	cl		; В функции 0AH максимальная длина указываается
				; с учетом завершающего символа, так что
				; добавить 1 к длине
	mov	byte ptr [si], cl ; В 0-м байте буфера нужно записать
				; максимальную длину строки
        mov	byte ptr [si+1], 0
        mov	ah, 0Ah
        mov	dx, si
        int	21h
	; Преобразовать введенную строку в 0-терминальную
	mov	bx, 0
	mov	bl, [si+1]	; В 1-м байте буфера содержится фактическая
				; длина строки
	add	si, 2           ; Фактические символы введенной строки
				; начинаются со 2-го байта буфера
	mov	byte ptr bx[si], 0
	; Скопировать данные из вспомогательного буфера в выходную строку
	pop	di
	call	StrCpy
	; Выполнить перевод строки
	mov	si, offset CRSt
	call	PrnStr
	; Восстановить регистры
	pop	di
	pop	si
	pop	bx
	pop	dx
	pop	cx
	pop	ax

	ret
InpStr	endp

; Выводит на экран в текущую позицию курсора указанную строку.
; Строка должна быть нультерминальной (признаком конца строки является 0)
;
; Вход:  DS:SI - адрес начала нультерминальной строки
;
PrnStr	proc
	; Сохранить регистры
	push	ax
	push	dx
	push	bx
	; Получить в AX длину строки
	call	StrLen
	; Будем использовать для вывода функцию DOS 09H, поэтому
	; 0-терминальную строку превращаем в '$'-терминальную
	mov	bx, ax
	mov	byte ptr bx[si], '$'
	; Вывести строку
	mov	ah, 09h
	mov	dx, si
	int	21h
	; Снова сделать строку 0-терминальной
	mov	byte ptr bx[si], 0
	; Восстановить регистры
	pop	bx
	pop	dx
	pop	ax

	ret
PrnStr	endp

; Возвращает длину нультерминальной строки (кол-во символов в строке)
;
; Вход:  DS:SI - адрес начала нультерминальной строки, в которой выполняется поиск
; Выход: AX - длина строки
;
StrLen	proc
	; Сохранить регистры
	push	si
	; Выполнить проход по строке пока не дойдем до конца (нулевой байт)
	mov	ax, 0
SL1:	cmp	byte ptr [si], 0
	je	SL2		; Дошли до конца строки - выход
	inc	ax
	inc	si
	jmp	SL1
	; Восстановить регистры
SL2:	pop	si

	ret
StrLen	endp

; Копирует нультерминальную строку в другую строку
;
; Вход:  DS:SI - адрес начала исходной нультерминальной строки
;	 DS:DI - адрес начала строки, в которую выполняется копирование
;
StrCpy	proc
	; Сохранить регистры
	push	ax
	push	si
	push	di
	; Выполнять копир., пока не дойдем до конца исх. строки (нулевой байт)
SC1:	mov	al, [si]
	mov	[di], al
	cmp	al, 0
	je	SC2		; Дошли до конца строки - выход
	inc	si
	inc	di
	jmp	SC1		; Новая итерация
SC2:	; Восстановить регистры
	pop	di
	pop	si
	pop	ax

	ret
StrCpy	endp

; Ищет индекс 1-го вхождения подстроки в строку
;
; Вход:  DS:DI - адрес начала нультерминальной основной строки, в которой
;                выполняется поиск
;        DS:SI - адрес начала нультерминальной подстроки, которую ищем
; Выход: DL - признак успешного завершения поиска (1-подстрока найдена;
;             0-подстрока не найдена). DL=0, если строка и/или подстрока - пустые.
;	 AX - индекс позиции (начиная с 0) в основной строке, с которой
;             начинается 1-е вхождение подстроки. Имеет смысл только при DL=1
;
StrPos	proc
	; Сохранить регистры
	push	si
	push	di
	push	cx
	push	bx
	push	es
	; Формируем кадр стека для хранения локальных переменных процедуры
	push	bp
	mov	bp, sp
	push	0               ; Адрес начала основной строки (далее [bp - 2])
	push	0		; Длина основной строки (далее [bp - 4])
	push	0               ; Адрес начала подстроки (далее [bp - 6])
	push	0               ; Длина подстроки (далее [bp - 8])
	; Начальная инициализация
	mov	dl, 0		; Пока еще ничего не нашли
	cld			; Сбросить флаг DF - проходы по строкам вперед
	push	ds		; Поместить в ES тот че адрес, что и в DS
	pop	es              ; (для дальнейших строковых команд)
	mov	[bp - 2], di	; Сохранить адрес начала основной строки
	mov	[bp - 6], si	; Сохранить адрес начала подстроки
	mov	si, [bp - 2]	; Вычислить длину
	call	StrLen		; основной строки
	cmp	ax, 0		; Проверить, возможно основная строка пустая
	je	@SP4		; Если основная строка пустая - выход
	mov	[bp - 4], ax	; Сохранить длину основной строки
	mov	si, [bp - 6]	; Вычислить длину
	call	StrLen		; подстроки
	cmp	ax, 0		; Проверить, возможно подстрока пустая
	je	@SP4		; Если подстрока пустая - выход
	mov	[bp - 8], ax	; Сохранить длину подстроки
	; Цикл поиска вхождения начального символа подстроки в основную строку.
	; Поиск в основной строке начинаем с позиции, следующей за позицией,
	; в которой нашли такое вхождение на предыдущей итерации цикла
	; (на начальной итерации ищем от начального символа основной строки).
	; Поиск ведем до 1-го совпадения или до конца основной строки.
	mov	di, [bp - 2]	; В DI - адрес начала основной строки
	mov	cx, [bp - 4]	; В CX - длина основной строки
@SP1:	mov	si, [bp - 6]	; В SI - адрес начала подстроки
	mov	al, [si]	; В AL - начальный символ подстроки
	repne	scasb		; Ищем позицию вхождения символа AL в осн. стр.
	jne	@SP4		; Дошли до конца основной строки и не нашли
				; символ - выход
	; DI указывает на позицию символа следующего после найденного символа AL
	; в основной строке
	; Проверить, что начиная с DI в основной строке осталось символов не
	; меньше, чем "длина_подстроки-1"
	mov	bx, [bp - 8]
	dec	bx		; В BX - "длина_подстроки-1"
	cmp	cx, bx          ; В CX кол-во символов от DI до конца осн. стр.
	jl	@SP4		; В основной строке осталось символов меньше,
				; чем в подстроке - выход
	push	cx		; Сохранить длину остатка основной строки
	push	di		; и позицию символа, следующего после
				; найденного в основной строке (для последующих
				; возможных поисков)
	cmp	bx, 0		; Если "длина_подстроки-1"=0, значит подстрока найдена
	je      @SP2
	mov	cx, bx          ; В CX сравнений не больше, чем "длина_подстроки-1"
	inc	si              ; В подстроке перейти на символ следующий после
				; начального
	repe	cmpsb		; Сравниваем остаток основной строки (начиная с
				; с символа DI) с остатком подстроки (начиная с
				; символа, следующего за начальным)
	jne	@SP3
@SP2:	; Подстрока успешно найдена в основной строке
	mov	ax, di		; DI указывает на позицию символа в осн. строке
				; который следует за последним символом найденной
				; подстроки
	sub	ax, [bp - 8]	; AX указывает на позицию в основной строке
				; начального символа найденной подстроки
	sub	ax, [bp - 2]    ; В AX индекс позиции (от 0) вхождения подстроки
				; в основную строку
	mov	dl, 1		; В DL - признак успешного нахождения подстроки
	pop	di		; Перед завершением извлечь ранее сохраненный DI
	pop	cx		; Перед завершением извлечь ранее сохраненный CX
	jmp     @SP4
@SP3:	; Подстрока не найдена
	pop	di		; В DI позиция в основной строке, с которой
				; нужно начинать новый поиск
	mov	bx, di
	sub	bx, [bp - 2]
	mov	cx, [bp - 4]	; В CX длина остатка основной строки, начиная
	sub	cx, bx		; с позиции DI
	jmp	@SP1            ; Повторяем процесс поиска от новой позиции DI
@SP4:	; Восстановить регистры
	mov	sp, bp
	pop	bp

	pop	es
	pop	bx
	pop	cx
	pop	di
	pop	si

	ret
StrPos	endp

; Процедура выполняет преобразование двухбайтового целого числа без знака
; в символьное ASCII-представление в указанной системе счисления.
; Поддерживаются следующие системы счисления:
;  - двочиная (цифры 0..1 и буква "B" в конце)
;  - восьмеричная (цифры 0..7 и буква "O" в конце)
;  - десятичная (цифры 0..9 без буквы в конце)
;  - шестнадцатеричная (цифры 0..9,A..F и буква "H" в конце)
;
; Вход:  AX - значение двухбайтового целого числа без знака
;        DS:SI - адрес начала нультерминальной строки, в которую нужно записать результат
;        DH - система счисления, в которую нужно преобразовать число
;              2 -  двоичная;
;              8 -  восьмеричная;
;              10 - десятичная;
;              16 - шестнадцатеричная;
;
IntToStr proc
	; Сохранить регистры
	push	ax
	push	cx
	push	dx
	push	bx
	; Получить в регистре BX длину символьного представления числа
	push	ax
	push	dx
	mov	bx, 0
	mov	cx, 0
	mov	cl, dh
	mov	dx, 0
ITS1:	div	cx
	mov	dx, 0
	inc	bx
	cmp	ax, 0
	jne	ITS1		; Цикл до тех пор, пока не останется значащих разрядов в исходном числе
	pop	dx
	pop	ax
	; Записать в конец строки символ обозначающий систему счисления и 0-завершающий символ
	cmp	dh, 2           ; Для двоичной системы счисления
	jne	ITS2
	inc	bx
	mov	byte ptr bx[si], 0
	dec	bx
	mov	byte ptr bx[si], 'B'
	jmp	ITS6
ITS2:	cmp	dh, 8           ; Для восьмеричной системы счисления
	jne	ITS3
	inc	bx
	mov	byte ptr bx[si], 0
	dec	bx
	mov	byte ptr bx[si], 'O'
	jmp	ITS6
ITS3:	cmp	dh, 10          ; Для десятичной системы счисления
	jne	ITS4
	mov	byte ptr bx[si], 0
	jmp	ITS6
ITS4:	cmp	dh, 16          ; Для шестнадцатеричной системы счисления
	jne	ITS5		; Неверное значение входного параметра DH - выход
	inc	bx
	mov	byte ptr bx[si], 0
	dec	bx
	mov	byte ptr bx[si], 'H'
	jmp	ITS6
ITS5:	mov	bx, 0		; Никакого преобразования не будет - пустая строка
	mov	byte ptr bx[si], 0
	jmp	ITS8
	; Цикл преобразования числа в строковое представление
ITS6:	mov	cx, 0
	mov	cl, dh
ITS7:	mov	dx, 0
	div	cx
	push	si
	mov	si, dx
	mov	dl, DigSymbTab[si] ; Соотв. символ из строки DigSymbTab
	pop	si
	dec	bx
	mov     byte ptr bx[si], dl
	cmp	ax, 0
	jne	ITS7		; Цикл до тех пор, пока не останется значащих разрядов в исходном числе

ITS8:
	; Восстановить регистры
	pop	bx
	pop	dx
	pop	cx
	pop	ax

	ret
IntToStr endp

code	ends

; Сегмент данных программы
data	segment	para public use16 "data"
; Текстовые сообщения
Msg1		db	'STRING IS : ', 0
Msg2		db	'SUBSTRING IS : ', 0
Msg3		db	'SUBSTRING IS FOUND AT POSITION : '
StPosStr	db	6 dup (0)	; Строковое значение найденной позиции
Msg4		db	'SUBSTRING IS NOT FOUND', 0
CRSt		db	13,10, 0	; Перевод строки
; Переменные программы
MainSt		db	254+1 dup(0)	; Содержимое основной строки
SubSt		db	254+1 dup(0)	; Содержимое подстроки
StMaxLen	dw	254		; Максимальное кол-во символов в строках
; Переменные для процедуры InpStr
InpStrBuf	db	2+254+1 dup(0)	; Буфер ввода строки
; Таблица цифровых символов
DigSymbTab	db	'0123456789ABCDEF', 0

data	ends

; Сегмент стека программы
stk	segment stack	use16
	db	256 dup (0)
stk	ends

end	main		; Конец программы с точкой входа main


