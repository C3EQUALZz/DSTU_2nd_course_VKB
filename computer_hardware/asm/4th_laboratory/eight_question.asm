.8086
.model tiny                   ; Определяем модель памяти как tiny
.code
org 100h                     ; Указываем, что код начинается с адреса 100h (для .COM файлов)

start:
    mov bx, 4                ; Устанавливаем BX в 4 (индекс для работы с массивами mass1 и mass2)
    mov cl, 8                ; Устанавливаем CL в 8 (количество бит для обработки)

a0:
    mov al, mass1[bx]       ; Загружаем байт из массива mass1 по индексу BX в AL
    mov ah, 00010101b       ; Загружаем фиксированное значение в AH (бинарное 00010101)
    sub cl, 8                ; Уменьшаем CL на 8 (подготовка к сдвигу)
    neg cl                   ; Инвертируем CL (CL = 8 - CL)
    cmp cl, 5                ; Сравниваем CL с 5
    jb a1                    ; Если CL < 5, переходим к метке a1
    sub cl, 5                ; Уменьшаем CL на 5

a1:
    shr ah, cl               ; Сдвигаем AH вправо на количество бит, указанное в CL
    sub cl, 5                ; Уменьшаем CL на 5
    neg cl                   ; Инвертируем CL (CL = 5 - CL)
    xor al, ah               ; Выполняем побитовую операцию XOR между AL и AH
    mov ah, 00010101b       ; Загружаем фиксированное значение в AH снова
    shl ah, cl               ; Сдвигаем AH влево на количество бит, указанное в CL
    xor al, ah               ; Выполняем побитовую операцию XOR между AL и AH
    shl ah, 5                ; Сдвигаем AH влево на 5 бит
    xor al, ah               ; Выполняем побитовую операцию XOR между AL и AH

    mov mass2[bx], al       ; Сохраняем результат в массив mass2 по индексу BX
    dec bx                   ; Уменьшаем BX для перехода к следующему элементу
    jns a0                   ; Если BX >= 0, продолжаем цикл (пока BX не станет отрицательным)

    retn                     ; Возвращаемся из программы

mass1 db 11001100b, 10101011b, 00011101b, 11101000b, 11100011b ; Исходный массив
mass2 db 5 dup(0)          ; Инициализируем массив mass2 нулями (5 элементов)
end start                  ; Завершаем программу, указывая точку входа
