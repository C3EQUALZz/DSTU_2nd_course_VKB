org 100h                     ; Указываем, что код начинается с адреса 100h (для .COM файлов)

start:
    jmp beg                  ; Переходим к метке beg

arrlow  dw 4050h             ; Переменная arrlow, инициализированная значением 4050h (16-ричное)
arrhi   dw 5553h             ; Переменная arrhi, инициализированная значением 5553h (16-ричное)
count   dw 0                 ; Переменная count, инициализированная нулем (для хранения счетчика)
crlf    db 13, 10, 0        ; Символы для новой строки (CR и LF)

beg:
    push cs                  ; Сохраняем сегмент кода в стеке
    pop  ds                  ; Загружаем сегмент данных из стека
    push cs                  ; Сохраняем сегмент кода в стеке
    pop  es                  ; Загружаем сегмент дополнительного сегмента из стека
    mov  bx, 0               ; Обнуляем регистр BX (используется как счетчик)
    mov count, bx            ; Инициализируем переменную count значением BX (0)
    mov  cx, 32              ; Устанавливаем CX в 32 (количество итераций)
    mov  ax, arrlow          ; Загружаем значение arrlow в AX
    mov  dx, arrhi           ; Загружаем значение arrhi в DX

m0:
    add  ax, ax              ; Удваиваем значение AX (сдвиг влево на 1 бит)
    adc  dx, dx              ; Удваиваем значение DX с учетом переноса
    jnc  m2                  ; Если не было переноса, переходим к m2
    cmp  bx, count           ; Сравниваем BX с count (если перенос был)
    jc   m3                  ; Если BX < count, переходим к m3
    mov  count, bx           ; Обновляем count значением BX (если BX больше)

m3:
    mov  bx, 0               ; Обнуляем BX
    jmp  m4                  ; Переходим к m4

m2:
    inc  bx                  ; Увеличиваем BX на 1 (если перенос не был)

m4:
    loop m0                  ; Уменьшаем CX и повторяем цикл, пока CX не станет 0

    cmp  bx, count           ; Сравниваем BX с count
    jc   m3a                 ; Если BX < count, переходим к m3a
    mov  count, bx           ; Обновляем count значением BX

m3a:
    mov  bx, 0               ; Обнуляем BX

    mov  cx, 32              ; Устанавливаем CX в 32 (количество итераций)
    mov  ax, arrlow          ; Загружаем значение arrlow в AX
    mov  dx, arrhi           ; Загружаем значение arrhi в DX

m5:
    add  ax, ax              ; Удваиваем значение AX
    adc  dx, dx              ; Удваиваем значение DX с учетом переноса
    jc   m6                  ; Если был перенос, переходим к m6
    call print0              ; Вызываем процедуру print0 для вывода "0"
    jmp  m7                  ; Переходим к m7

m6:
    call print1              ; Вызываем процедуру print1 для вывода "1"

m7:
    loop m5                  ; Уменьшаем CX и повторяем цикл, пока CX не станет 0

    mov si, offset crlf      ; Загружаем адрес новой строки в SI
    call print_string        ; Вызываем процедуру для вывода строки
    mov ax, count            ; Загружаем значение count в AX
    call print_num_uns       ; Вызываем процедуру для вывода беззнакового числа
    mov ax, 4C00h           ; Завершаем программу с кодом возврата 0
    int 21h                  ; Вызов прерывания DOS для выхода

print0:
    push ax                  ; Сохраняем AX на стеке
    push dx                  ; Сохраняем DX на стеке
    mov dl, "0"              ; Загружаем символ '0' в DL
    mov ah, 2                ; Устанавливаем функцию вывода символа
    int 21h                  ; Вызов прерывания DOS для вывода символа
    pop dx                   ; Восстанавливаем DX из стека
    pop ax                   ; Восстанавливаем AX из стека
    ret                      ; Возвращаемся из процедуры

print1:
    push ax                  ; Сохраняем AX на стеке
    push dx                  ; Сохраняем DX на стеке
    mov dl, "1"              ; Загружаем символ '1' в DL
    mov ah, 2                ; Устанавливаем функцию вывода символа
    int 21h                  ; Вызов прерывания DOS для вывода символа
    pop dx                   ; Восстанавливаем DX из стека
    pop ax                   ; Восстанавливаем AX из стека
    ret                      ; Возвращаемся из процедуры

include "emu8086.inc"       ; Подключаем файл emu8086.inc для дополнительных определений

; Определения для работы с вводом/выводом
;   DEFINE_SCAN_NUM
   DEFINE_PRINT_STRING
;   DEFINE_PTHIS
;   DEFINE_GET_STRING
;   DEFINE_CLEAR_SCREEN
;   DEFINE_PRINT_NUM
   DEFINE_PRINT_NUM_UNS
