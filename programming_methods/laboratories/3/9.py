"""
Задача №3088. Золотые слитки

Даны N золотых слитков известных масс.
Определите, какую наибольшую массу золота можно унести, если вместимость рюкзака не превышает S.

Входные данные

Программа получает на вход целое число S — вместимость рюкзака, не превосходящее 10000 и количество слитков N,
не превосходящее 300. Далее следует N целых неотрицательных чисел, не превосходящих 100000 — веса слитков.

Выходные данные

Программа должна вывести единственное целое число — максимально возможных вес золота, который поместится в данный рюкзак.
"""
from typing import List


def max_gold_weight(capacity: int, weights: list) -> int:
    """
    Определяет максимальный вес золота, который можно унести в рюкзак.

    Алгоритм использует динамическое программирование для решения задачи о рюкзаке.
    1. Инициализируется массив `achievable_weights`, где индекс представляет вес,
       а значение (0 или 1) указывает, достижим ли этот вес с использованием
       доступных слитков.
    2. Начальное значение `achievable_weights[0]` устанавливается в 1, так как
       нулевой вес всегда достижим (не беря ни одного слитка).
    3. Для каждого слитка (веса) из списка `weights` обновляется массив
       `achievable_weights` в обратном порядке, чтобы избежать повторного
       использования одного и того же слитка в текущей итерации.
    4. После обработки всех слитков, массив `achievable_weights` будет содержать
       информацию о всех достижимых весах до максимальной вместимости рюкзака.
    5. В конце функция ищет максимальный индекс в массиве, который равен 1,
       что соответствует максимальному весу, который можно унести в рюкзак.

    :param capacity: Максимальная вместимость рюкзака.
    :param weights: Список весов золотых слитков.
    :return: Максимально возможный вес золота, который можно унести в рюкзак.
    """
    # Инициализация массива для хранения достижимых весов
    achievable_weights: List[int] = [0] * (capacity + 1)
    achievable_weights[0] = 1  # Нулевой вес всегда достижим

    # Проходим по каждому слитку
    for weight in weights:
        # Обновляем массив достижимых весов в обратном порядке
        for current_capacity in range(capacity, weight - 1, -1):
            if achievable_weights[current_capacity - weight] == 1:
                achievable_weights[current_capacity] = 1

    # Находим максимальный вес, который можно унести
    for i in range(capacity, -1, -1):
        if achievable_weights[i] == 1:
            return i  # Возвращаем максимальный вес

    return 0  # Если ничего не удалось унести


def main() -> None:
    capacity, n = map(int, input().split())
    weights: List[int] = list(map(int, input().split()))

    max_weight: int = max_gold_weight(capacity, weights)
    print(max_weight)


if __name__ == "__main__":
    main()
