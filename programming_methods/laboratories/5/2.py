"""
Задача №1704. Маршрут для гонца

В королевстве N; городов, пронумерованных от 1 до N. Столица имеет номер 1.
Каждый город окружен городской стеной с 4 воротами.
Ворота пронумерованы следующим образом: ворота i-го города (1 ≤ i ≤ N) имеют номера 4i−3, 4i−2, 4i−1, 4i.
Через каждые ворота проходит ровно 1 дорога, которая ведет до некоторых ворот другого города
(заметьте, что может существовать несколько дорог между двумя городами).
По всем дорогам можно двигаться в обоих направлениях. Благодаря системе туннелей и мостов дороги не пересекаются вне городов.

Королевский гонец должен развесить копии Очень важного Королевского Указа на внешней стороне всех ворот каждого города.
Гонец может свободно передвигаться от одних ворот к другим в пределах города, но вне города он может двигаться только по дорогам.
Гонец выезжает из столицы и должен туда вернуться после выполнения задания.

Может ли гонец выполнить поручение, проходя через каждые ворота только один раз?
Выход из города через ворота только для того, чтобы вывесить на их внешней стороне указ,
а затем немедленное возвращение в город, считается за один проход через ворота.

Входные данные

Первая строка входного файла содержит целое число N (2 ≤ N ≤ 1000).
Каждая из последующих 2N строк описывает одну дорогу и содержит 2 целых числа, разделенных
пробелом: номера ворот, соединенных дорогой.

Выходные данные

В первую строку выходного файла выведите Yes или No в зависимости от того, может ли поручение гонца быть выполнено,
если проходить через ворота только один раз.
В случае если это возможно, вторая строка выходного файла должна содержать 4N целых чисел,
разделенных пробелом: номера ворот в порядке прохождения через них гонцом.
Если существует несколько решений, выведите любое из них.
"""
from collections import deque
from dataclasses import dataclass
from typing import List, Tuple, cast


@dataclass
class Road:
    """
    Класс для представления дороги между воротами двух городов.

    Атрибуты:
        from_city (int): Город, откуда идет дорога.
        to_city (int): Город, в который ведет дорога.
        from_gate (int): Ворота города, откуда идет дорога.
        to_gate (int): Ворота города, в который ведет дорога.
        visited (bool): Флаг, который указывает, была ли дорога уже посещена гонцом.
    """
    from_city: int
    to_city: int
    from_gate: int
    to_gate: int
    visited: bool = False


class CityGraph:
    def __init__(self, n: int, roads_data: List[Tuple[int, int]]) -> None:
        """
        Класс для представления графа города, который состоит из множества дорог между воротами.

        :params n: Количество городов.
        :params roads_data: Список дорог в формате (ворота1, ворота2), которые соединяют города.
        """
        self.n = n
        self.roads: List[Road] = []
        self.graph: List[List[int]] = [[] for _ in range(n + 1)]

        # Заполняем граф и список дорог
        for gate1, gate2 in roads_data:
            from_city = (gate1 + 3) // 4
            to_city = (gate2 + 3) // 4
            road_index = len(self.roads)
            self.graph[from_city].append(road_index)
            self.graph[to_city].append(road_index)
            self.roads.append(Road(from_city, to_city, gate1, gate2))

    def mark_road_visited(self, road_index: int) -> None:
        """
        Помечаем дорогу как посещенную.
        :param road_index: Индекс дороги в списке roads.
        """
        self.roads[road_index].visited = True

    def __getitem__(self, city: int) -> List[int]:
        """
        Возвращает список дорог для данного города.
        :param city: Номер города.
        :returns: Список индексов дорог, которые выходят из города.
        """
        return self.graph[city]


def can_complete_task(n: int, graph: CityGraph) -> List[int]:
    """
    Определяет, может ли гонец пройти через все ворота каждого города, следуя правилам задачи.

    Алгоритм работы:
    1. Инициализируем стек `stack`, который используется для отслеживания путей, и список `ans`, который хранит
       последовательность ворот, через которые проходит гонец.
    2. Устанавливаем текущий город `cur_city` в 1 (столица).
    3. Входим в цикл, который продолжает работать, пока:
       - У текущего города остались дороги, ведущие из него.
       - Либо пока есть элементы в стеке, к которым нужно вернуться.
    4. Если у текущего города нет непосещённых дорог:
       - Проверяем, есть ли в стеке элементы, к которым можно вернуться.
       - Если стек пуст, завершаем цикл, так как все ворота обработаны.
       - Иначе возвращаемся к предыдущему городу, извлекая информацию из стека: предыдущий город, ворота, через
         которые мы вышли и вошли, добавляем их в список `ans`, и обновляем текущий город.
    5. Если есть непосещённые дороги, выбираем последнюю дорогу из списка текущего города:
       - Проверяем, была ли эта дорога уже посещена. Если да, удаляем её из списка дорог города и продолжаем цикл.
       - Иначе помечаем дорогу как посещённую и определяем, куда перемещаться дальше:
           - Если текущий город совпадает с отправной точкой дороги, добавляем в стек текущий город и ворота
             (выходные и входные), переходим в соседний город.
           - Если текущий город совпадает с конечной точкой дороги, аналогично добавляем информацию в стек,
             но с учётом обратного порядка ворот, и перемещаемся в другой конец дороги.
    6. После завершения цикла проверяем, совпадает ли длина списка `ans` с `4 * n` (общее число ворот).
       - Если да, возвращаем список `ans`, содержащий порядок обхода ворот.
       - Если нет, задача неразрешима, возвращаем пустой список.

    :param n: Количество городов.
    :param graph: Граф, представляющий города и дороги между воротами.
    :returns: Порядок ворот, через которые должен пройти гонец, если задача решаема. Если задача не решаема, возвращает пустой список.
    """
    stack = deque()  # Используем deque как стек
    ans = []  # Список ворот
    cur_city = 1

    while True:
        if not graph[cur_city]:
            if not stack:
                break
            # Возвращаемся к предыдущему городу
            to_gate, from_gate, prev_city = (stack.pop() for _ in range(3))
            ans.extend((to_gate, from_gate))
            cur_city = prev_city
            continue

        road_index = graph[cur_city][-1]

        # Если дорога уже посещена
        if graph.roads[road_index].visited:
            graph[cur_city].pop()
            continue

        # Обновляем состояние дороги и перемещаемся в соседний город
        if cur_city == graph.roads[road_index].from_city:
            stack.extend([cur_city, graph.roads[road_index].from_gate, graph.roads[road_index].to_gate])
            graph.mark_road_visited(road_index)
            cur_city = graph.roads[road_index].to_city
        else:
            stack.extend([cur_city, graph.roads[road_index].to_gate, graph.roads[road_index].from_gate])
            graph.mark_road_visited(road_index)
            cur_city = graph.roads[road_index].from_city

    # Проверяем, удалось ли пройти через все ворота
    return ans if len(ans) == 4 * n else []


def main() -> None:
    n: int = int(input())

    roads_data: List[Tuple[int, int]] = cast(
        List[Tuple[int, int]],
        [tuple(map(int, input().split())) for _ in range(2 * n)]
    )

    graph = CityGraph(n, roads_data)

    result = can_complete_task(n, graph)

    if result:
        print("Yes", " ".join(map(str, result)), sep="\n")
    else:
        print("No")


if __name__ == "__main__":
    main()
