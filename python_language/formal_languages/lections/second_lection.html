<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<link rel="stylesheet" type="text/css" href="css/css_for_lections.css">
<link rel="stylesheet" type="text/css" href="css/container.css">
<link rel="stylesheet" type="text/css" href="css/title_of_lection.css">
<link rel="stylesheet" type="text/css" href="css/ordered_list.css">
<link rel="stylesheet" type="text/css" href="css/subtitle_of_lection.css">
<link rel="stylesheet" type="text/css" href="css/proofs_examples_etc.css">

<div class="text">

  <div class="center_any_title">
    <h1 class="title_of_lecture"> Теория контекстно-свободных языков</h1>
  </div>

  <div class="container">
    
    <h4 class="proof_or_theorem"> Определение 1.</h4>
    <p>
      <br> КС-грамматика называется приведенной, если она не имеет циклов, ε-правил и бесполезных символов.
    </p>

    <p>
      <br> Рассмотрим основные алгоритмы приведения КС-грамматик.
      <br> Перед всеми другими исследованиями и преобразованиями КС-грамматик выполняется проверка существования языка грамматики.
    </p>

  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Алгоритм 1. Проверка существования языка грамматики</h3>
  </div>
  
  <div class="container">
    <p>
      <br> Вход: КС-грамматика G = (V<sup>T</sup>, V<sup>N</sup>, P, S).
      <br> Выход: заключение о существовании или отсутствии языка грамматики.
    </p>

    <p>
      <br> Определим множество нетерминалов, порождающих терминальные строки
      <br> N = {Z | Z ∈ V<sup>N</sup>, Z ⇒ *x, x ∈ V<sup>T</sup>}.
    </p>

    <p>
      <br> <b><i>Шаг 1.</i></b> Положить N<sub>0</sub> = Ø.
      <br> <b><i>Шаг 2.</i></b> Вычислить:
      <br> N<sub>i</sub> = N<sub>i-1</sub> U {A | (A → α) ∈ P и α ∈ (N<sub>i-1</sub> U V<sup>T</sup>)}$
      <br> <b><i>Шаг 3.</i></b> Если N<sub>i</sub> ≠ N<sub>i-1</sub>, то положить i = i+1 и перейти к пункту 2, иначе считать N = N<sub>i</sub>
    </p>

    <p>
      <br>Если S ∈ N, то выдать сообщение о том, что язык грамматики существует, иначе сообщить об отсутствии языка.
    </p>
  
    <h4 class="proof_or_theorem">Пример 2.1.</h4>
    <p>
      <br> Дана грамматика G = ({0, 1}, {S, A, B}, P, S), где множество правил P:
      <br> Построим последовательность приближений множества N: 
      <br> N<sub>0</sub> = Ø;
      <br> N<sub>1</sub> = {A, B};
      <br> N<sub>2</sub> = {S, A, B};
      <br> N<sub>3</sub> = {S, A, B}.
      <br> Т.к. N<sub>2</sub> = N<sub>3</sub>, то N = {S, A, B}, следовательно, язык грамматики существует, потому что начальный символ S ∈ N.
    </p>
    
    <h4 class="proof_or_theorem">Определение 2.</h4>
    <p>
      <br> Бесполезными символами грамматики называют: 
      <br> - нетерминалы, не порождающие терминальных строк, т.е. множество символов {X | X ∈ V<sup>N</sup>, ¬∃(X ⇒ *x), x ∈ V<sup>*</sup><sub>T</sub>}
      <br> - недостижимые нетерминалы, порождающие терминальные строки, т.е. множество символов {X | X ∈ V<sup>N</sup>, ¬∃(S ⇒ *αXß), ∃(X ⇒ *x); α,ß ∈ V<sup>*</sup>; x ∈ V<sup>*</sup><sub>T</sub>}
      <br> - недостижимые терминалы, т.е. множество символов {X | X ∈ V<sup>N</sup>, ¬∃(S ⇒ *αXß); α,ß ∈ V<sup>*</sup>}
    </p>
  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Алгоритм 2. Устранение нетерминалов, не порождающих терминальных строк </h3>
  </div>
    
  <div class="container">
    <p>
      <br> Вход: КС-грамматика G = (V<sup>T</sup>, V<sup>N</sup> , P, S).
      <br> Выход: КС-грамматика G‘ = (V<sub>T</sub>, V‘<sub>N</sub>, P‘, S), такая, что L(G`) = L(G) 
      <br> (и для всех Z ∈ V`<sub>N</sub> существуют выводы Z ⇒ *x, где x ∈ V<sup>*</sup><sub>T</sub>).
    </p>

    <p>
      <br><b><i>Шаг 1.</i></b> Определить множество нетерминалов, порождающих терминальные строки, с помощью <b>алгоритма 2.1.</b>
      <br><b><i>Шаг 2.</i></b> Вычислить V`<sub>N</sub> = V<sub>N</sub> ∩ N, N<sub>Б</sub> = V<sub>N</sub> - V`<sub>N</sub>, P` = P - P<sub>Б</sub> где P<sub>Б</sub> ⊆ P - это множество правил, содержащих бесполезные нетерминалы X ∈ N<sub>Б</sub>.
    </p>

    <h4 class="proof_or_theorem">Пример 2.2.</h4>

    <p>
      <br>Дана грамматика G = ({a, b, c}, {S, A, B, C}, P, S) с правилами P:
      <ol class="points">
        <li> S → ab;
        <li> S → AC;
        <li> A → AB;
        <li> B → b;
        <li> C → cb
      </ol>

      <p><br> Преобразуем ее в эквивалентную грамматику G′ по алгоритму 2.2:</p>
    </p>

    <p>
      <br> N<sub>0</sub> = Ø
      <br> N<sub>1</sub> = {S, B, C};
      <br> N<sub>2</sub> = {S, B, C}.
    </p>

    <p>
      <br> Т.к. N<sub>1</sub> = N<sub>2</sub>, то N = {S, B, C}. После удаления бесполезных нетерминалов и правил вывода, получим грамматику G` = ({a, b, c}, {S, B, C}, P`, S) с правилами P′:
      <ol class="points">
        <br>
        <li> S → ab;</li>
        <li> B → b;</li>
        <li> C → cb;</li>
      </ol>
    </p>
  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Алгоритм 3. Устранение недостижимых символов</h3>
  </div>

  <div class="container">
    <p>
      <br>Вход: КС-грамматика  G = (V<sub>T</sub>, V<sub>N</sub>, P, S).
      <br>Выход: КС-грамматика, G` = (V<sub>T</sub>, V`<sub>N</sub>, P`, S) такая, что L(G`) = L(G) и для всех Z ∈ V` существует вывод S ⇒ *αZß, где α,ß ∈ V`<sup>*</sup>.
    </p>

    <p>
      <br>Определим множество достижимых символов Z грамматики G, т.е. множество W = {Z | Z ∈ V, ∃(S ⇒ *αZß); α,ß ∈ V<sup>*</sup>}
    </p>

    <p>
      <br><b><i>Шаг 1.</i></b> Положить W<sub>0</sub> = S
      <br><b><i>Шаг 2.</i></b> Вычислить очередное приближение следующим образом:
      W<sub>i</sub> = W<sub>i - 1</sub> U {X | X ∈ V, (A → αXß) ∈ P, A ∈ W<sub>i - 1</sub>; α,ß ∈ V<sup>*</sup>}
      <br><b><i>Шаг 3.</i></b> Если W<sub>i</sub> ≠ W<sub>i-1</sub>, то положить i := i+1 и перейти к шагу 2, иначе считать W = W<sub>i</sub>
      <br><b><i>Шаг 4.</i></b> Вычислить V`<sub>N</sub> = V<sub>N</sub> ∩ W, V`<sub>T</sub> = V<sub>T</sub> ∩ W, V<sub>Б</sub> = V - W
      P` = P - P<sub>Б</sub>, где P<sub>Б</sub> ⊆ P - это множество правил, содержащих бесполезные нетерминалы X ∈ V<sub>Б</sub>.
    </p>

    <h4 class="proof_or_theorem">Пример 2.3.</h4>
    <p>
      <br>Дана грамматика G = ({a, b, c}, {S, A, B, C}, P, S) с правилами P′:
      <ol class="points">
        <li>S → ab;</li>
        <li>B → b;</li>
        <li>C → cb;</li>
      </ol>
    </p>

    <p>
      Преобразуем ее в эквивалентную грамматику G′ по алгоритму 2.3: 
      <br> W<sub>0</sub> = {S};
      <br> W<sub>1</sub> = {S, a, b};
      <br> W<sub>2</sub> = {S, a, b}.
    </p>

    <p>
      Т.к. W<sub>1</sub> = W<sub>2</sub>, то W = {S, a, b}.  Множество недостижимых символов V<sub>T</sub> = {B, C, c}. 
      Тогда после удаления недостижимых символов, получим грамматику G` = ({a, b}, {S}, P, S) с правилом P′: S → ab.
    </p>
  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Алгоритм 4. Устранение ε-правил</h3>
  </div>

  <div class="container">
    <p>
      <br>Вход: КС-грамматика G = (V<sup>T</sup>, V<sup>N</sup>, P, S).
      <br>Выход: Эквивалентная КС-грамматика G‘ = (V<sub>T</sub>, V‘<sub>N</sub>, P‘, S) без ε-правил для всех нетерминальных символов,
       кроме начального, который не должен встречаться в правых частях правил грамматики.
    </p>

    <p>
      <br><b><i>Шаг 1.</i></b> В исходной грамматике G найти ε-порождающие нетерминальные символы A ∈ V<sub>N</sub>, такие, что A ⇒ *ε.
      <br>- 1.1 Положить N<sub>0</sub> = {A | (A → ε) ∈ P}
      <br>- 1.2 Вычислить N<sub>i</sub> = N<sub>i-1</sub> ∪ {B | (B → α) ∈ P, α ∈ N<sup>*</sup><sub>i-1</sub>}
      <br>- 1.3 Если N<sub>i</sub> ≠ N<sub>i-1</sub>, то положить i := i+1 и перейти к пункту 1.2, иначе считать N = N<sub>i</sub>.
    </p>

    <p>
      <br><b><i>Шаг 2.</i></b> Из множества P правил исходной грамматики G перенести во множество P′ все правила, за исключением ε-правил, т.е.
      <br> P` = P - {(A → ε) ∈ P для всех A ∈ V<sub>N</sub>}
    </p>

    <p>
      <br><b><i>Шаг 3.</i></b> Пополнить множество P′ правилами, которые получаются из каждого правила этого множества путем исключения всевозможных комбинаций
      ε-порождающих нетерминалов в правой части. Полученные при этом ε-правила во множество P′ не включать. 
    </p>

    <p>
      <br><b><i>Шаг 4.</i></b> Если S ∈ N, то P` = P ∪ {S` → ε, S` → S}, V`<sub>N</sub> = V<sub>N</sub> ∪ S`, где V ∩ {S} = Ø иначе
      V`<sub>N</sub> = V<sub>N</sub>, S` = S.
    </p>

    <h4 class="proof_or_theorem">Пример 4.4</h4>
    <p>
      <br> Дана грамматика G=({0,1}, {S, A, B}, P, S) и правилами P:

      <ol class="points">
        <li>S → AB;</li>
        <li>A → 0A | ε;</li>
        <li>B → 1B | ε;</li>
      </ol>

      <p><br> Преобразуем ее в эквивалентную грамматику по <b>алгоритму 4</b>.</p>
    </p>

    <p>
      <br><b><i>Шаг 1.</i></b>
      N<sub>0</sub> = {A, B};
      N<sub>1</sub> = {S, A, B};
      N<sub>2</sub> = {S, A, B}.
      Т.к. N<sub>1</sub> = N<sub>2</sub>, то искомое множество построено и N = {S, A, B}.
    </p>
    
    <p>
      <br><b><i>Шаг 2, 3.</i></b> Множество P′:
      <br>- S → AB | A| B
      <br>- A → 0A | 0;
      <br>- B → 1B |1.
    </p>
    
    <p>
      <br><b><i>Шаг 4.</i></b> Т.к. S ∈ N, то введем новый нетерминал С и пополним множество P` правилом вида C → S | ε. Результирующая грамматика будет иметь вид:
      G` = {(0, 1), {S, A, B, C}, P, C} с правилами P′:
      <ol class="points">
        <li>C → S | ε;</li>
        <li>S → AB | A | B;</li>
        <li>A → 0A | 0;</li>
        <li>B → B1 | 1.</li>
      </ol>
    </p>
  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Устранение цепных правил</h3>
  </div>

  <div class="container">
    <p>
      <br>Вход: КС-грамматика G=(V<sub>T</sub>, V<sub>N</sub>, P, S)
      <br>Выход: Эквивалентная КС-грамматика G′ = (V<sub>T</sub>, V<sub>`N</sub>, P′, S′) без цепных правил, т.е. правил вида A → B, где A, B ∈ V<sub>N</sub>.
    </p>

    <p>
      <br><b><i>Шаг 1.</i></b> Для каждого нетерминала A вычислить множество выводимых из него нетерминалов, т.е. множество N<sup>A</sup> ={B | A ⇒ *B, где B ∈ V<sub>N</sub>}.
      <br>- 1.1 Положить N<sub>0</sub><sup>A</sup> = {A}.
      <br>- 1.2 Вычислить N<sub>i</sub><sup>A</sup> = N<sub>i-1</sub><sup>A</sup> ∪ {C | (B → C) ∈ P , B ∈ N<sub>i-1</sub><sup>A</sup>, C ∈ V<sub>N</sub>}.
      <br>- 1.3 Если N<sub>i</sub><sup>A</sup> ≠ N<sub>i-1</sub><sup>A</sup>,  то  положить i := i+1  и  перейти  к  пункту 1.2, иначе считать N<sup>A</sup> = N<sub>i</sub><sup>A</sup>.
    </p>

    <p>
      <br><b><i>Шаг 2.</i></b> Построить множество P′ так:
      <br> Если (B → α) ∈ P не является цепным правилом (α ∉ V<sup>N</sup>, то) включить в P′ правило A → α для каждого A, такого, что B ∈ N<sup>A</sup>.
    </p>

    <h4 class="proof_or_theorem">Пример 2.5.</h4>

    <p>
      <br> Грамматика G=({+, n}, {L, M, N}, P, L) с правилами P:
      <ol class="points">
        <li>L → M;</li>
        <li>M → N;</li>
        <li>N → N+ | n.</li>
      </ol>
    </p>

    <p>
      <br> Преобразуем ее в эквивалентную грамматику G′ по <b>алгоритму 5</b>.
    </p>

    <p>
      <br><b><i>Шаг 1.</i></b> Т.к. N<sub>2</sub>L = N<sub>3</sub>L, то N<sub>L</sub> = {L, M, N}. 
    </p>
    
    <p>
      <br><b><i>Шаг 2.</i></b> Преобразовав правила вывода грамматики, получим грамматику с правилами P′: ...
    </p>
  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Алгоритм 6. Устранение левой факторизации правил</h3>
  </div>
   
  <div class="container">
    <p>
      <br>Вход: КС-грамматика G = (V<sub>T</sub>, V<sub>N</sub>, P, S).
      <br>Выход: Эквивалентная КС-грамматика G′ = (V<sub>T</sub> , V<sub>'T</sub>, P′, S′) .. без одинаковых префиксов в правых частях правил, определяющих нетерминалы. 
    </p>

    <p>
      <br><b><i>Шаг 1.</b></i> Записать все правила для нетерминала X, имеющие одинаковые префиксы α ∈ V<sup>*</sup>, в виде одного правила с альтернативами:
      <br> X → &alpha;&beta;<sub>1</sub> | &alpha;&beta;<sub>2</sub> | ... | &alpha;&beta;<sub>n</sub>; &beta;<sub>1</sub>&beta<sub>2</sub>, ..., &beta;<sub>n</sub> ∈ V<sup>*</sup>
    </p>

    <p>
      <br><b><i>Шаг 2.</b></i> Вынести  за  скобки  влево  префикс  α  в  каждой  строке-альтернативе: X → α(β<sub>1</sub>|β<sub>2</sub>|...|β<sub>n</sub>). 
    </p>

    <p>
      <br><b><i>Шаг 3.</b></i> Обозначить новым нетерминалом Y выражение, оставшееся в скобках:  X → αY, Y → β<sub>1</sub> | β<sub>2</sub> |...| β<sub>n</sub>. 
    </p>

    <p>
      <br><b><i>Шаг 4.</b></i> Пополнить множество нетерминалов новым нетерминалом Y .. и заменить правила, подвергшиеся факторизации, новыми правилами для X и Y. 
    </p>

    <p>
      <br><b><i>Шаг 5.</b></i> Повторить шаги 1-4 для всех нетерминалов грамматики, для которых это возможно и необходимо. 
    </p>

    <h4 class="proof_or_theorem">Пример 2.6.</h4>

    <p>
      <br>Дана грамматика G=({k, l, m, n}, {S}, P, S)  с правилами P ... Преобразуем  ее  в эквивалентную грамматику G′ по <b>алгоритму 6</b>:      
    </p>

    <p>
      <br><b><i>Шаг 1.</b></i> S → kSl | kSm | n.
    </p>

    <p>
      <br><b><i>Шаг 2.</b></i> S → kS (l | m) | n. 
    </p>

    <p>
      <br><b><i>Шаг 3,4.</b></i> Пополнив множество нетерминалов новым нетерминалом С и заменив правила, подвергшиеся факторизации, получим грамматику.
      <br> G' = ({k, l, m, n}, {S, C}, P', S)
    </p>

    <p>
      <br> с правилами P′:
      <br> - S → kSC; 
      <br> - S → n; 
      <br> - C → l; 
      <br> - C → m.
    </p>
  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Алгоритм 7. Устранение прямой левой рекурсии</h3>
  </div>

  <div class="container">

    <p>
      <br>Вход: КС-грамматика G=(V<sub>T</sub>, V<sub>N</sub>, P, S).
      <br>Выход:  Эквивалентная  КС-грамматика G′ = (V<sub>T</sub>, V<sub>'N</sub>, P′, S′)  без  прямой левой рекурсии, т.е. без правил вида A→ Aα, A ∈ V<sub>N</sub>, α ∈ V<sup>*</sup>.
    </p>

    <p>
      <br><b><i>Шаг 1.</b></i> Вывести из грамматики все правила для рекурсивного нетерминала X:
      <br> X → X&alpha;<sub>1</sub>|X&alpha;<sub>2</sub>|....|X&alpha;<sub>m</sub>;
      <br> (X ∈ V<sub>N</sub>; &alpha;<sub>1</sub>, &alpha;<sub>2</sub>, ..., &alpha;<sub>m</sub> ∈ V<sup>*</sup>) 
    </p>

    <p>
      <br><b><i>Шаг 2.</b></i> Внести новый нетерминал Y так, чтобы он описывал любой «хвост» строки, порождаемой рекурсивным нетерминалом X.
      <br> Y → &alpha;<sub>1</sub>Y | &alpha;<sub>2</sub>Y | ... | &alpha;<sub>m</sub>Y;
      <br> Y → &alpha;<sub>1</sub> | &alpha;<sub>2</sub> | ... | &alpha;<sub>m</sub>;  
    </p>

    <p>
      <br><b><i>Шаг 3.</b></i> Заменить в рекурсивном правиле для X правую часть, используя новый нетерминал и все не рекурсивные правила для X так, чтобы генерируемый язык не изменился.
      <br> X → &beta;<sub>1</sub>Y | &beta;<sub>2</sub>Y | ... | &beta;<sub>n</sub>Y;
      <br> X → &beta;<sub>1</sub> | &beta;<sub>2</sub> | ... | &beta;<sub>n</sub>;
      <br> Y → &alpha;<sub>1</sub>Y | &alpha;<sub>2</sub>Y | ... | &alpha;<sub>m</sub>Y;
      <br> Y → &alpha;;<sub>1</sub> | &alpha;<sub>2</sub> | ... | &alpha;<sub>m</sub>;
    </p>

    <p>
      <br><b><i>Шаг 4.</b></i> Пополнить множество нетерминалов грамматики новым нетерминалом Y. Пополнить множество правил грамматики правилами, полученными на шаге 3.
    </p>

    <p>
      <br><b><i>Шаг 5.</b></i> Повторить действия шагов 1-4 для всех рекурсивных нетерминалов грамматики, после чего полученные множества нетерминалов и правил принять в качестве V'<sub>N</sub> и P′.
    </p>

    <h4 class="proof_or_theorem">Пример 4.7.</h4>

    <p>
      <br> Дана грамматика G=({a, b, c, d, z} ,{S, A, B, C}, P, S) с правилами P:
      <br> - S → Aa; 
      <br> - A → Bb; 
      <br> - B → Cc|d; 
      <br> - C → Ccbz | dbz.
    </p>

    <p>  
      <br> После устранения  прямой  левой  рекурсии  получим  эквивалентную  грамматику G′=({a,b,c,d,z}, {S, A, B, C, Z}, P′, S) с правилами  P′:
      <br> - S → Aa;
      <br> - A → Bb;
      <br> - B → Cc|d;
      <br> - C → dbzZ | dbz;
      <br> - Z → cbzZ | cdz. 
    </p>

  </div>

</div>