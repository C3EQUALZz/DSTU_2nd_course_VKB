<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<link rel="stylesheet" type="text/css" href="css/css_for_lections.css">
<link rel="stylesheet" type="text/css" href="css/container.css">
<link rel="stylesheet" type="text/css" href="css/title_of_lection.css">
<link rel="stylesheet" type="text/css" href="css/ordered_list.css">
<link rel="stylesheet" type="text/css" href="css/subtitle_of_lection.css">
<link rel="stylesheet" type="text/css" href="css/proofs_examples_etc.css">

<div class="text">

  <div class="center_any_title">
    <h1 class="title_of_lecture"> Теория контекстно-свободных языков</h1>
  </div>

  <div class="container">
    
    <h4 class="proof_or_theorem"> Определение 1.</h4>
    <p>
      <br> КС-грамматика называется приведенной, если она не имеет циклов, ε-правил и бесполезных символов.
    </p>

    <p>
      <br> Рассмотрим основные алгоритмы приведения КС-грамматик.
      <br> Перед всеми другими исследованиями и преобразованиями КС-грамматик выполняется проверка существования языка грамматики.
    </p>

  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Алгоритм 1. Проверка существования языка грамматики</h3>
  </div>
  
  <div class="container">
    <p>
      <br> Вход: КС-грамматика G = (V<sup>T</sup>, V<sup>N</sup>, P, S).
      <br> Выход: заключение о существовании или отсутствии языка грамматики.
    </p>

    <p>
      <br> Определим множество нетерминалов, порождающих терминальные строки
      <br> N = {Z | Z ∈ V<sup>N</sup>, Z ⇒ *x, x ∈ V<sup>T</sup>}.
    </p>

    <p>
      <br> <b><i>Шаг 1.</i></b> Положить N<sub>0</sub> = Ø.
      <br> <b><i>Шаг 2.</i></b> Вычислить:
      <br> N<sub>i</sub> = N<sub>i-1</sub> U {A | (A → α) ∈ P и α ∈ (N<sub>i-1</sub> U V<sup>T</sup>)}$
      <br> <b><i>Шаг 3.</i></b> Если N<sub>i</sub> ≠ N<sub>i-1</sub>, то положить i = i+1 и перейти к пункту 2, иначе считать N = N<sub>i</sub>
    </p>

    <p>
      <br>Если S ∈ N, то выдать сообщение о том, что язык грамматики существует, иначе сообщить об отсутствии языка.
    </p>
  
    <h4 class="proof_or_theorem">Пример 2.1.</h4>
    <p>
      <br> Дана грамматика G = ({0, 1}, {S, A, B}, P, S), где множество правил P:
      <br> Построим последовательность приближений множества N: 
      <br> N<sub>0</sub> = Ø;
      <br> N<sub>1</sub> = {A, B};
      <br> N<sub>2</sub> = {S, A, B};
      <br> N<sub>3</sub> = {S, A, B}.
      <br> Т.к. N<sub>2</sub> = N<sub>3</sub>, то N = {S, A, B}, следовательно, язык грамматики существует, потому что начальный символ S ∈ N.
    </p>
    
    <h4 class="proof_or_theorem">Определение 2.</h4>
    <p>
      <br> Бесполезными символами грамматики называют: 
      <br> - нетерминалы, не порождающие терминальных строк, т.е. множество символов {X | X ∈ V<sup>N</sup>, ¬∃(X ⇒ *x), x ∈ V<sup>*</sup><sub>T</sub>}
      <br> - недостижимые нетерминалы, порождающие терминальные строки, т.е. множество символов {X | X ∈ V<sup>N</sup>, ¬∃(S ⇒ *αXß), ∃(X ⇒ *x); α,ß ∈ V<sup>*</sup>; x ∈ V<sup>*</sup><sub>T</sub>}
      <br> - недостижимые терминалы, т.е. множество символов {X | X ∈ V<sup>N</sup>, ¬∃(S ⇒ *αXß); α,ß ∈ V<sup>*</sup>}
    </p>
  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Алгоритм 2.</h3>
  </div>
    
  <div class="container">
    <p>
      <br> Вход: КС-грамматика G = (V<sup>T</sup>, V<sup>N</sup> , P, S).
      <br> Выход: КС-грамматика G‘ = (V<sub>T</sub>, V‘<sub>N</sub>, P‘, S), такая, что L(G`) = L(G) 
      <br> (и для всех Z ∈ V`<sub>N</sub> существуют выводы Z ⇒ *x, где x ∈ V<sup>*</sup><sub>T</sub>).
    </p>

    <p>
      <br><b><i>Шаг 1.</i></b> Определить множество нетерминалов, порождающих терминальные строки, с помощью <b>алгоритма 2.1.</b>
      <br><b><i>Шаг 2.</i></b> Вычислить V`<sub>N</sub> = V<sub>N</sub> ∩ N, N<sub>Б</sub> = V<sub>N</sub> - V`<sub>N</sub>, P` = P - P<sub>Б</sub> где P<sub>Б</sub> ⊆ P - это множество правил, содержащих бесполезные нетерминалы X ∈ N<sub>Б</sub>.
    </p>

    <h4 class="proof_or_theorem">Пример 2.2.</h4>
    <p>
      <ol class="points">
        <p> Дана грамматика G = ({a, b, c}, {S, A, B, C}, P, S) с правилами P:</p>
        <li> S → ab;
        <li> S → AC;
        <li> A → AB;
        <li> B → b;
        <li> C → cb
        Преобразуем ее в эквивалентную грамматику G′ по алгоритму 2.2:
      </ol>
    </p>

    <p>
      <br> N<sub>0</sub> = Ø
      <br> N<sub>1</sub> = {S, B, C};
      <br> N<sub>2</sub> = {S, B, C}.
    </p>

    <p>
      <br> Т.к. N<sub>1</sub> = N<sub>2</sub>, то N = {S, B, C}. После удаления бесполезных нетерминалов и правил вывода, получим грамматику G` = ({a, b, c}, {S, B, C}, P`, S) с правилами P′:
      <ol class="points">
        <li> S → ab;</li>
        <li> B → b;</li>
        <li> C → cb;</li>
      </ol>
    </p>
  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Алгоритм 3. Устранение недостижимых символов</h3>
  </div>

  <div class="container">
    <p>
      <br>Вход: КС-грамматика  G = (V<sub>T</sub>, V<sub>N</sub>, P, S).
      <br>Выход: КС-грамматика, G` = (V<sub>T</sub>, V`<sub>N</sub>, P`, S) такая, что L(G`) = L(G) и для всех Z ∈ V` существует вывод S ⇒ *αZß, где α,ß ∈ V`<sup>*</sup>.
    </p>

    <p>
      <br>Определим множество достижимых символов Z грамматики G, т.е. множество W = {Z | Z ∈ V, ∃(S ⇒ *αZß); α,ß ∈ V<sup>*</sup>}
    </p>

    <p>
      <br><b><i>Шаг 1.</i></b> Положить W<sub>0</sub> = S
      <br><b><i>Шаг 2.</i></b> Вычислить очередное приближение следующим образом:
      W<sub>i</sub> = W<sub>i - 1</sub> U {X | X ∈ V, (A → αXß) ∈ P, A ∈ W<sub>i - 1</sub>; α,ß ∈ V<sup>*</sup>}
      <br><b><i>Шаг 3.</i></b> Если W<sub>i</sub> ≠ W<sub>i-1</sub>, то положить i := i+1 и перейти к шагу 2, иначе считать W = W<sub>i</sub>
      <br><b><i>Шаг 4.</i></b> Вычислить V`<sub>N</sub> = V<sub>N</sub> ∩ W, V`<sub>T</sub> = V<sub>T</sub> ∩ W, V<sub>Б</sub> = V - W
      P` = P - P<sub>Б</sub>, где P<sub>Б</sub> ⊆ P - это множество правил, содержащих бесполезные нетерминалы X ∈ V<sub>Б</sub>.
    </p>

    <h4 class="proof_or_theorem">Пример 2.3.</h4>
    <p>
      <br>Дана грамматика G = ({a, b, c}, {S, A, B, C}, P, S) с правилами P′:
      <ol class="points">
        <li>S → ab;</li>
        <li>B → b;</li>
        <li>C → cb;</li>
      </ol>
    </p>

    <p>
      Преобразуем ее в эквивалентную грамматику G′ по алгоритму 2.3: 
      <br> W<sub>0</sub> = {S};
      <br> W<sub>1</sub> = {S, a, b};
      <br> W<sub>2</sub> = {S, a, b}.
    </p>

    <p>
      Т.к. W<sub>1</sub> = W<sub>2</sub>, то W = {S, a, b}.  Множество недостижимых символов V<sub>Б</sub> = {B, C, c}. 
      Тогда после удаления недостижимых символов, получим грамматику G` = ({a, b}, {S}, P, S) с правилом P′: S → ab.
    </p>
  </div>

  <div class="center_any_title">
    <h3 class="subtitle_of_lecture">Алгоритм 4. Устранение ε-правил</h3>
  </div>

  <div class="container">
    <p>
      <br>Вход: КС-грамматика G = (V<sup>T</sup>, V<sup>N</sup>, P, S).
      <br>Выход: Эквивалентная КС-грамматика G‘ = (V<sub>T</sub>, V‘<sub>N</sub>, P‘, S) без ε-правил для всех нетерминальных символов,
       кроме начального, который не должен встречаться в правых частях правил грамматики.
    </p>

    <p>
      <br><b><i>Шаг 1.</i></b> В исходной грамматике G найти ε-порождающие нетерминальные символы A ∈ V<sub>N</sub>, такие, что A ⇒ *ε.
      <br>- 1.1 Положить N<sub>0</sub> = {A | (A → ε) ∈ P}
      <br>- 1.2 Вычислить N<sub>i</sub> = N<sub>i-1</sub> ∪ {B | (B → α) ∈ P, α ∈ N<sup>*</sup><sub>i-1</sub>}
      <br>- 1.3 Если N<sub>i</sub> ≠ N<sub>i-1</sub>, то положить i := i+1 и перейти к пункту 1.2, иначе считать N = N<sub>i</sub>.
    </p>

    <p>
      <br><b><i>Шаг 2.</i></b> Из множества P правил исходной грамматики G перенести во множество P′ все правила, за исключением ε-правил, т.е.
      <br> P` = P - {(A → ε) ∈ P для всех A ∈ V<sub>N</sub>}
    </p>

    <p>
      <br><b><i>Шаг 3.</i></b> Пополнить множество P′ правилами, которые получаются из каждого правила этого множества путем исключения всевозможных комбинаций
      ε-порождающих нетерминалов в правой части. Полученные при этом ε-правила во множество P′ не включать. 
    </p>

    <p>
      <br><b><i>Шаг 4.</i></b> Если S ∈ N, то P` = P ∪ {S` → ε, S` → S}, V`<sub>N</sub> = V<sub>N</sub> ∪ S`, где V ∩ {S} = Ø иначе
      V`<sub>N</sub> = V<sub>N</sub>, S` = S.
    </p>

    <h4 class="proof_or_theorem">Пример 4.4</h4>
    <p>
      <br>Дана грамматика G=({0,1}, {S, A, B}, P, S) и правилами P:
      <ol class="points">
        <li>S → AB;</li>
        <li>A → 0A | ε;</li>
        <li>B → 1B | ε;</li>
      </ol>
      <br> Преобразуем ее в эквивалентную грамматику по <b>алгоритму 4</b>.
    </p>

    <p>
      <br><b><i>Шаг 1.</i></b>
      N<sub>0</sub> = {A, B};
      N<sub>1</sub> = {S, A, B};
      N<sub>2</sub> = {S, A, B}.
      Т.к. N<sub>1</sub> = N<sub>2</sub>, то искомое множество построено и N = {S, A, B}.
    </p>
    
    <p>
      <br><b><i>Шаг 2, 3.</i></b> Множество P′:
      <br>- S → AB | A| B
      <br>- A → 0A | 0;
      <br>- B → 1B |1.
    </p>
    
    <p>
      <br><b><i>Шаг 4.</i></b> Т.к. S ∈ N, то введем новый нетерминал С и пополним множество P` правилом вида C → S | ε. Результирующая грамматика будет иметь вид:
      G` = {(0, 1), {S, A, B, C}, P, C} с правилами P′:
      <ol class="points">
        <li>C → S | ε;</li>
        <li>S → AB | A | B;</li>
        <li>A → 0A | 0;</li>
        <li>B → B1 | 1.</li>
      </ol>
    </p>
  </div>

  

</div>